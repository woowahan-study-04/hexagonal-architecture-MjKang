# 04. 유스케이스 구현하기

# 풍부한 도메인 모델 vs 빈약한 도메일 모델

도메인 모델을 구현하는 방법에 대해서 열려 있으므로, 문맥에 맞는 적합한 아키텍쳐 스타일을 고를 수 있다. 이는 적합한 방식을 선택하길수 있으므로, 축복인 동시에 지침이 없으므로 저주이기도 하다

자주 논의 되는 사항은 DDD철학을 따르는 풍부한 도메인 모델을 구현할 것인지? 빈약한 도메인 모델을 구현할것인지? 이다.

### 풍부한 도메인 모델

### 특징

1. 애플리케이션 코어에 있는 엔티티에서 가능한 한 많은 도메인 로직이 구현

    - 엔티티들은 상태를 변경하는 메소드를 제공하고, 비즈니스 규칙에 맞는 유효한 변경만을 허용.

1. 유스케이스는 도메인 모델의 진입점으로 동작하며, 유스케이스는 사용자의 의도만을 표현하며 많은 비즈니스 규칙이 유스케이스 구현체 대신 엔티티에 위치

### 빈약한 도메인 모델

1. 엔티티는 상태를 표현하는 필드와 이 값을 바꾸기 위한 getter, setter 메소드만 포함하고 어떤 도메인 로직도 가지고 있지 않다.
2. 비즈니스 규칙 검증, 엔티티 상태 변경, 데이터베이스 저장을 담당하는 아웃고잉 포트에 엔티티를 전달할 책임 역시 유스케이스 클래스에 존재

‘**풍부함**’이 엔티티 대신 유스케이스에 존재하면, ‘**빈약한 도메인 모델**’ 그 반대라면 ‘**풍부한 도메인 몸델**’

# 유스케이스마다 다른 출력 모델

유스케이스가 할 일을 다하고 나면 호출자에게 무엇을 반환해야 할까?

출력도 유스케이스에 맞게 구체적인수록 좋다. 출력은 호출자에게 꼭 필요한 데이터만 들고 있어야 한다.

‘**송금하기**’ 유스케이스 코드에서는 Acoonut를 통채로 반환하는 대신에, boolean 값 하나를 반환했다. 이는 이 맥락에서 반환할 수 있는 가장 구체적인 최소한의 값이다.

과연 맞는것일까? 다른 호출자도 사용할수 있도록 해당 데이터에 접근할 전용 유스케이스를 만들어야 하지 않을까?

정답은 존재하지 않지만 구체적으로 유지를 위해 가능한 적게 반환하자.

유스케이스들간에 출력 모델을 공유하게 되면, 유스케이스들도 강하게 결합된다.

이유는 한 유스케이스에서 출력 모델에 새로운 필드가 필요해지면, 이 값과 관련이 없는 다른 유스케이스에서도 이 필드를 처리해야 하기 때문이다.

공유 모델은 장기적으로 갖가지 이유때문에 커지게 되어있으모로, 단일책임원칙을 적용하고 모델을 분리해서 유지하는 것은 유스케이스 결합을 제거하는 데 도움이 된다.

# 읽기 전용 유스케이스는 어떨까?

UI에 계좌의 잔액을 표시해야 한다고 가정해보자. 이를 위해 새로운 유스케이스를 구현해야 할까?

### UI단

UI단에서는 ‘**계좌 잔고 보여주기’** 라고 부를 수 있는 특정 유스케이스를 구현하기 위해 요청한 데이터가 필요할 수도 있다. 만약 전체 프로젝트의 맥락에서 이러한 작업이 유스케이스로 분류된다면 어떻게든 다른 유스케이스와 비슷한 방식으로 구현해야 한다.

### Apllication Core 관점

이 작업은 단순한 데이터 쿼리이다. 그렇기 때문에 프로젝트 맥락에서 유스케이스로 간주되지 않는다면 실제 유스케이스와 구분하기 위해 쿼리로 구현할수 있다.

이를 구현하기 위한 방법은 쿼리를 위한 인커밍 전용 포트를 만들고 이를 ‘**쿼리 서비스**’에 구현하는 것

```java
@RequiredArgsConstructor
@RestController
@RequestMapping("/accounts")
class GetAcconutBalanceService implements GetAccountBalanceQuery {
    private final LoadAccountPort loadAccountPort ;

    @Overrided
    public Money getAccountBalance(AccountId accountId) {
				return loadAccountPort.loadAccount(accountId, LocaDateTime.now())
							.calculateBalance();
    }
}
```

쿼리 서비스는 유스케이스 서비스와 동일한 방식으로 동작.

GetAccountBalanceQuery라는 인커밍 포트를 구현하고, 데이터베이스로부터 실제로 데이터를 로드하기 위해 LoadAccountPort라는 아웃고잉 포트를 호출한다.

이처럼 읽기 전용 쿼리는 쓰기가 가능한 유스케이스와 코드상에서 명확하게 구분된다. 이런 방식은 CQS(Command-Query Separation)나 CQRS(Command-Query Responsibility Segregation)같은 개념과 아주 잘 맞는다.

- CQS
1. 모든 메소드는 한번의 액션에서 상태를 변경하는 커맨드든 데이터를 반환하는 쿼리든 한가지 액션만 취해야 한다는 것
2. 다시 말하자면 질문을 할때 대답을 변경하지 말라는 것

```java
// CQS 위반
private int x;

public int increment_and_return_x() {
  lock x;   // by some mechanism
  x = x + 1;
  int x_copy = x;

  unlock x; // by some mechanism
  return x_copy;
}
```

```java
// CQS 준수
private int x;

public int value() {
  return x;
}

void increment() {
  x = x + 1;
}
```

- CQRS
1. 시스템에서 명령을 처리하는 책임과 조회를 처리하는 책임을 분리하는 것이 핵심
2. 명령 : 시스템의 상태를 변경하는 작업
3. 조회 : 시스템의 상태를 반환하는 작업
4. 즉 명령과 조회로 작업의 책임을 분리하는 것
![image](https://user-images.githubusercontent.com/31757314/168423308-380fbbb4-6139-401d-92e4-b3277dbe2887.png)

1. Application의 BIZ정책이나 제약(비즈니스 로직)은 대부분 데이터 변경 (C,U,D) 작업에서 처리되고, 데이터 조회(R)작업은 단순 데이터 조회가 대부분
2. 두 역할을 하나의 동일한 Domain Model로 처리하게 되면, 각 업무 영역에서의 새로운 요구사항으로 인한 Model 변경이 누적되면서 C,U,D를 위한 모델과 조회를 위한 모델간에 차이가 발생하게 됨
3. 즉. 각 업무 영역에 필요치 않은 Domain 속성들로 인해 복잡도는 한 없이 증가하고 Domain Model은 애초 설계 의도와는 다른 방향으로 변질

# 유지 보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

도메인 로직을 우리가 원하는 대로 구현할수 있도록 허용하지만, 입출력 모델을 독립적으로 모델링 한다면 원치 않는 부수효과를 피할 수 있다.

이는 유스케이스 간에 모델을 공유하는 것보다는 더 많은 작업이 필요하다. 각 유스케이스마다 별도의 모델을 만들어야 하고, 이 모델과 엔티티를 매핑해야 한다.

**유스케이스별로 모델을 만들시 장점**

1. 유스케이스를 명확하게 이해할수 있으모로, 장기적으로 유지보수가 더 쉽다.
2. 여러명의 작업자가 작업중인 유스케이스를 건드리지 않은 채로, 여러개의 유스케이스를 동시에 작업할수 있다.

**꼼꼼한 입력 유효성 검증, 유스케이스별로 입출력 모델**은 지속 가능한 코드를 만드는 데 큰 도움이 된다.
