## 의존성 역전하기


### `단일 책임 원칙`

통상적인 일반적인 해석은 '하나의 컴포넌트는 오로지 한가지 일만 해야 하고 그것을 올바르게 수행해야 한다'
실제의도와 단일 책임 원칙의 실제 정의 '컴포넌트를 변경하는 이유는 오직 하나뿐이여야 한다'
만약 컴포넌트를 변경할 이유가 오로지 한가지라면 컴포넌트는 딱 한가지 일만하게 된다. 하지만 이보다 더 중요한 것은 변경할 이유가 오직 한가지라는 그 자체다.

아키텍쳐에서의 이의 의미는 '우리가 어떤 다른 이유로 소프트웨어를 변경하더라도 이 컴포넌트에 대해서는 전혀 신경 쓸 필요가 없다'
왜냐하면 소프트웨어가 변경하더라도 여전히 우리가 기대한 대로 동작할것이기 때문.

### `의존성 역전 원칙`
영속성 계층에 대한 도메인 계층의 의존성 때문에 영속성 계층을 변경할때마다 잠재적으로 도메인 계층도 변경해야 한다.
그러나 도메인 코드는 어플리케이션에서 가장 중요한 코드이므로 영속성 코드에 의해서 변경되게 하고 싶지 않다.

코드상의 어떤 의존성이든 그 방향을 바꿀수 있다.
1. 엔티티는 도메인 객체를 표현하고 도메인 코드는 이 엔티티들의 상태를 변경하는 일을 중심으로 하기 때문에 먼저 엔티티를 도메인 계층으로 올린다.
2. 영속성 계층의 리포지토리가 도메인 계층에 있는 엔티티에 의존하기 때문에 두 계층 사이의 순환 의존성이 생긴다.
3. 이 부분을 해결을 위해 도메인 계층에 리포지토리에 대한 인터페이스를 만들고 실제 리포지토리는 영속성 계층에서 구현한다.

![image](https://user-images.githubusercontent.com/31757314/167230848-d11cd124-bf18-42f9-895b-7030317b28e8.png)

### `클린 아키텍쳐`
도메인 코드가 바깥으로 향하는 어떤 의존성도 없어야 한다. 의존성 역전 원칙으로 모든 의존성이 도메인코드를 향한다.

아키텍쳐 코어에는 주변 유스케이스에서 접근하는 도메인 엔티티들이 있다. 유스케이스는 앞에서 서비스라고 불렀던 것들인데, 단일 책임을 갖기 위해 조금 더 세분화돼 있다.
이를 통해 넓은 서비스 문제를 피할수 있다.

도메인 코드에는 어떤 영속성 프레임워크나 UI 프레임 워크가 사용되지 알수 없기 때문에 특정 프레임워크에 특화된 코드를 가질수 없고 비즈니스 규칙에 집중할 수 있다.
그래서 도메인 코드를 자유롭게 모델링할 수 있다.

클린 아키텍쳐에는 대가가 따른다. 도메인 계층이 영속성이나 UI 같은 외부 계층과 철저하게 분리돼야 하므로 애플리케이션의 엔티티에 대한 모델을 각 계층에서 유지보수 해야 한다.
가령 영속성 계층에서 ORM 프레임워크를 사용한다고 해보자. 일반적으로 ORM프레임워크는 데이터베이스 구조 및 객체 필드와 데이터베이스 칼럼의 매핑을 서술한 메타데이터를 담고 있는 엔티티 클래스를 필요로 한다. 도메인 계층은 영속성 계층을 모르기 때문에 도메인 계층에서 사용한 엔티티 클래스를 영속성 계층에서 함께 사용할수 없고 두 계층에서 각각 엔티티를 만들어야 한다.

이는 바람직한 현상이다. 이것이 바로 도메인 코드를 프레임워크에 특화된 문제로부터 해방시키고자 했던, 결합이 제거된 상태다.

### `육각형 아키텍쳐(헥사고나 아키텍쳐)`
애플리케이션 코어가 육각형으로 표현되어 이 아키텍쳐의 이름이 됐다.

육각형 안에는 도메인 엔티티와 이와 상호작용하는 유스케이스가 있다. 육각형에서 외부로 향하는 의존성이 없기 대문에 클린 아키텍쳐에서 제시한 의존성 규칙이 그대로 적용된다. 대신 모든 의존성은 코어르 향한다.

육각형 밖에는 애플리케이션과 상호작용하는 다야한 어댑터들이 있다. 웹 브라우저와 상호작용하는 웹 어댑터, 외부 시스템과 상홍작용, 데이터베이스와 상호작용하는 어뎁터도 있다.

왼쪽은 애플리케이션을 주도하는 어뎁터이고 오른쪽은 주도되는 어뎁터이다.

코어와 어뎁터들간에 통신을 위해 애플리케이션 코드가 각각의 포트를 제공해야 한다.

이러한 핵심 개념으로 '포트와 어댑터' 아키텍쳐로도 알려져 있다. 가장 바깥쪽에 있는 계층은 애플리케이션과 다른 시스템 간의 번여ㅓㄱ을 담당하는 어뎁터로 구성돼 있다. 다음으로 포트와 유스케이스 구현체를 결합해서 애플리케이션 계층을 구성할 수 있는데, 이 두가지가 애플리케이션의 인터페이스를 정의하기 때문이다. 마지막 계층에는 도메인 엔티티가 위치한다.

### `유지보수 가능 소프트웨어를 만드는데 어떻게 도움이 될까?`
의존성 역전으로 의존을 제거함으로써, 영속성과 UI에 특화된 모든 문제로부터 도메인 로직의 결합을 제거하고 코드를 변경할 이유와 수를 줄일수 있다.
그리고 변경할 이유가 적을수록 유지보수성은 더 좋아진다.

도메인 코드는 비즈니스 문제에 딱 맞게 모델링될수 있고, 영속성 코드와 UI코드도 영속성 문제와 UI문에제 맞서 자유롭게 모델링 될수 있다.

